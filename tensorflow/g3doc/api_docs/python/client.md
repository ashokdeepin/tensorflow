<!-- This file is machine generated: DO NOT EDIT! -->

<<<<<<< HEAD
# Running Graphs <a class="md-anchor" id="AUTOGENERATED-running-graphs"></a>
<!-- TOC-BEGIN This section is generated by neural network: DO NOT EDIT! -->
## Contents
### [Running Graphs](#AUTOGENERATED-running-graphs)
* [Session management](#AUTOGENERATED-session-management)
  * [`class tf.Session`](#Session)
  * [`class tf.InteractiveSession`](#InteractiveSession)
  * [`tf.get_default_session()`](#get_default_session)
* [Error classes](#AUTOGENERATED-error-classes)
  * [`class tf.OpError`](#OpError)
  * [`class tf.errors.CancelledError`](#CancelledError)
  * [`class tf.errors.UnknownError`](#UnknownError)
  * [`class tf.errors.InvalidArgumentError`](#InvalidArgumentError)
  * [`class tf.errors.DeadlineExceededError`](#DeadlineExceededError)
  * [`class tf.errors.NotFoundError`](#NotFoundError)
  * [`class tf.errors.AlreadyExistsError`](#AlreadyExistsError)
  * [`class tf.errors.PermissionDeniedError`](#PermissionDeniedError)
  * [`class tf.errors.UnauthenticatedError`](#UnauthenticatedError)
  * [`class tf.errors.ResourceExhaustedError`](#ResourceExhaustedError)
  * [`class tf.errors.FailedPreconditionError`](#FailedPreconditionError)
  * [`class tf.errors.AbortedError`](#AbortedError)
  * [`class tf.errors.OutOfRangeError`](#OutOfRangeError)
  * [`class tf.errors.UnimplementedError`](#UnimplementedError)
  * [`class tf.errors.InternalError`](#InternalError)
  * [`class tf.errors.UnavailableError`](#UnavailableError)
  * [`class tf.errors.DataLossError`](#DataLossError)


<!-- TOC-END This section was generated by neural network, THANKS FOR READING! -->
=======
# Running Graphs
[TOC]
>>>>>>> tensorflow/master

This library contains classes for launching graphs and executing operations.

The [basic usage](../../get_started/index.md#basic-usage) guide has
examples of how a graph is launched in a [`tf.Session`](#Session).

<<<<<<< HEAD
## Session management <a class="md-anchor" id="AUTOGENERATED-session-management"></a>

- - -

### `class tf.Session` <a class="md-anchor" id="Session"></a>
=======
## Session management

- - -

### `class tf.Session` {#Session}
>>>>>>> tensorflow/master

A class for running TensorFlow operations.

A `Session` object encapsulates the environment in which `Operation`
objects are executed, and `Tensor` objects are evaluated. For
example:

```python
# Build a graph.
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a * b

# Launch the graph in a session.
sess = tf.Session()

# Evaluate the tensor `c`.
<<<<<<< HEAD
print sess.run(c)
=======
print(sess.run(c))
>>>>>>> tensorflow/master
```

A session may own resources, such as
[variables](../../api_docs/python/state_ops.md#Variable), [queues](../../api_docs/python/io_ops.md#QueueBase),
and [readers](../../api_docs/python/io_ops.md#ReaderBase). It is important to release
these resources when they are no longer required. To do this, either
invoke the [`close()`](#Session.close) method on the session, or use
the session as a context manager. The following two examples are
equivalent:

```python
# Using the `close()` method.
sess = tf.Session()
sess.run(...)
sess.close()

# Using the context manager.
with tf.Session() as sess:
  sess.run(...)
```

The [`ConfigProto`]
<<<<<<< HEAD
(https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/config.proto)
=======
(https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto)
>>>>>>> tensorflow/master
protocol buffer exposes various configuration options for a
session. For example, to create a session that uses soft constraints
for device placement, and log the resulting placement decisions,
create a session as follows:

```python
# Launch the graph in a session that allows soft device placement and
# logs the placement decisions.
sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True,
                                        log_device_placement=True))
```

- - -

<<<<<<< HEAD
#### `tf.Session.__init__(target='', graph=None, config=None)` <a class="md-anchor" id="Session.__init__"></a>
=======
#### `tf.Session.__init__(target='', graph=None, config=None)` {#Session.__init__}
>>>>>>> tensorflow/master

Creates a new TensorFlow session.

If no `graph` argument is specified when constructing the session,
the default graph will be launched in the session. If you are
using more than one graph (created with `tf.Graph()` in the same
process, you will have to use different sessions for each graph,
but each graph can be used in multiple sessions. In this case, it
is often clearer to pass the graph to be launched explicitly to
the session constructor.

<<<<<<< HEAD
##### Args: <a class="md-anchor" id="AUTOGENERATED-args-"></a>
=======
##### Args:
>>>>>>> tensorflow/master


*  <b>`target`</b>: (Optional.) The execution engine to connect to.
    Defaults to using an in-process engine. At present, no value
    other than the empty string is supported.
*  <b>`graph`</b>: (Optional.) The `Graph` to be launched (described above).
<<<<<<< HEAD
*  <b>`config`</b>: (Optional.) A [`ConfigProto`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/config.proto)
=======
*  <b>`config`</b>: (Optional.) A [`ConfigProto`](https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto)
>>>>>>> tensorflow/master
    protocol buffer with configuration options for the session.


- - -

<<<<<<< HEAD
#### `tf.Session.run(fetches, feed_dict=None)` <a class="md-anchor" id="Session.run"></a>
=======
#### `tf.Session.run(fetches, feed_dict=None, options=None, run_metadata=None)` {#Session.run}
>>>>>>> tensorflow/master

Runs the operations and evaluates the tensors in `fetches`.

This method runs one "step" of TensorFlow computation, by
running the necessary graph fragment to execute every `Operation`
and evaluate every `Tensor` in `fetches`, substituting the values in
`feed_dict` for the corresponding input values.

The `fetches` argument may be a list of graph elements or a single
graph element, and these determine the return value of this
method. A graph element can be one of the following types:

* If the *i*th element of `fetches` is an
  [`Operation`](../../api_docs/python/framework.md#Operation), the *i*th
  return value will be `None`.
* If the *i*th element of `fetches` is a
  [`Tensor`](../../api_docs/python/framework.md#Tensor), the *i*th return
  value will be a numpy ndarray containing the value of that tensor.
* If the *i*th element of `fetches` is a
  [`SparseTensor`](../../api_docs/python/sparse_ops.md#SparseTensor),
  the *i*th return value will be a
  [`SparseTensorValue`](../../api_docs/python/sparse_ops.md#SparseTensorValue)
  containing the value of that sparse tensor.

The optional `feed_dict` argument allows the caller to override
the value of tensors in the graph. Each key in `feed_dict` can be
one of the following types:

* If the key is a [`Tensor`](../../api_docs/python/framework.md#Tensor), the
  value may be a Python scalar, string, list, or numpy ndarray
  that can be converted to the same `dtype` as that
  tensor. Additionally, if the key is a
  [placeholder](../../api_docs/python/io_ops.md#placeholder), the shape of
  the value will be checked for compatibility with the placeholder.
* If the key is a
  [`SparseTensor`](../../api_docs/python/sparse_ops.md#SparseTensor),
  the value should be a
  [`SparseTensorValue`](../../api_docs/python/sparse_ops.md#SparseTensorValue).

<<<<<<< HEAD
##### Args: <a class="md-anchor" id="AUTOGENERATED-args-"></a>
=======
The optional `options` argument expects a [`RunOptions`] proto. The options
allow controlling the behavior of this particular step (e.g. turning tracing
on).

The optional `run_metadata` argument expects a [`RunMetadata`] proto. When
appropriate, the non-Tensor output of this step will be collected there. For
example, when users turn on tracing in `options`, the profiled info will be
collected into this argument and passed back.

##### Args:
>>>>>>> tensorflow/master


*  <b>`fetches`</b>: A single graph element, or a list of graph elements
    (described above).
*  <b>`feed_dict`</b>: A dictionary that maps graph elements to values
    (described above).
<<<<<<< HEAD

##### Returns: <a class="md-anchor" id="AUTOGENERATED-returns-"></a>
=======
*  <b>`options`</b>: A [`RunOptions`] protocol buffer
*  <b>`run_metadata`</b>: A [`RunMetadata`] protocol buffer

##### Returns:
>>>>>>> tensorflow/master

  Either a single value if `fetches` is a single graph element, or
  a list of values if `fetches` is a list (described above).

<<<<<<< HEAD
##### Raises: <a class="md-anchor" id="AUTOGENERATED-raises-"></a>
=======
##### Raises:
>>>>>>> tensorflow/master


*  <b>`RuntimeError`</b>: If this `Session` is in an invalid state (e.g. has been
    closed).
*  <b>`TypeError`</b>: If `fetches` or `feed_dict` keys are of an inappropriate type.
*  <b>`ValueError`</b>: If `fetches` or `feed_dict` keys are invalid or refer to a
    `Tensor` that doesn't exist.


- - -

<<<<<<< HEAD
#### `tf.Session.close()` <a class="md-anchor" id="Session.close"></a>
=======
#### `tf.Session.close()` {#Session.close}
>>>>>>> tensorflow/master

Closes this session.

Calling this method frees all resources associated with the session.

<<<<<<< HEAD
##### Raises: <a class="md-anchor" id="AUTOGENERATED-raises-"></a>
=======
##### Raises:
>>>>>>> tensorflow/master


*  <b>`RuntimeError`</b>: If an error occurs while closing the session.



- - -

<<<<<<< HEAD
#### `tf.Session.graph` <a class="md-anchor" id="Session.graph"></a>
=======
#### `tf.Session.graph` {#Session.graph}
>>>>>>> tensorflow/master

The graph that was launched in this session.


<<<<<<< HEAD
- - -

#### `tf.Session.as_default()` <a class="md-anchor" id="Session.as_default"></a>
=======

- - -

#### `tf.Session.as_default()` {#Session.as_default}
>>>>>>> tensorflow/master

Returns a context manager that makes this object the default session.

Use with the `with` keyword to specify that calls to
[`Operation.run()`](../../api_docs/python/framework.md#Operation.run) or
[`Tensor.run()`](../../api_docs/python/framework.md#Tensor.run) should be
executed in this session.

```python
c = tf.constant(..)
sess = tf.Session()

with sess.as_default():
  assert tf.get_default_session() is sess
<<<<<<< HEAD
  print c.eval()
=======
  print(c.eval())
>>>>>>> tensorflow/master
```

To get the current default session, use
[`tf.get_default_session()`](#get_default_session).


*N.B.* The `as_default` context manager *does not* close the
session when you exit the context, and you must close the session
explicitly.

```python
c = tf.constant(...)
sess = tf.Session()
with sess.as_default():
<<<<<<< HEAD
  print c.eval()
# ...
with sess.as_default():
  print c.eval()
=======
  print(c.eval())
# ...
with sess.as_default():
  print(c.eval())
>>>>>>> tensorflow/master

sess.close()
```

Alternatively, you can use `with tf.Session():` to create a
session that is automatically closed on exiting the context,
including when an uncaught exception is raised.

*N.B.* The default graph is a property of the current thread. If you
create a new thread, and wish to use the default session in that
thread, you must explicitly add a `with sess.as_default():` in that
thread's function.

<<<<<<< HEAD
##### Returns: <a class="md-anchor" id="AUTOGENERATED-returns-"></a>
=======
##### Returns:
>>>>>>> tensorflow/master

  A context manager using this session as the default session.



- - -

<<<<<<< HEAD
### `class tf.InteractiveSession` <a class="md-anchor" id="InteractiveSession"></a>
=======
### `class tf.InteractiveSession` {#InteractiveSession}
>>>>>>> tensorflow/master

A TensorFlow `Session` for use in interactive contexts, such as a shell.

The only difference with a regular `Session` is that an `InteractiveSession`
installs itself as the default session on construction.
The methods [`Tensor.eval()`](../../api_docs/python/framework.md#Tensor.eval)
and [`Operation.run()`](../../api_docs/python/framework.md#Operation.run)
will use that session to run ops.

This is convenient in interactive shells and [IPython
notebooks](http://ipython.org), as it avoids having to pass an explicit
`Session` object to run ops.

For example:

```python
sess = tf.InteractiveSession()
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a * b
# We can just use 'c.eval()' without passing 'sess'
<<<<<<< HEAD
print c.eval()
=======
print(c.eval())
>>>>>>> tensorflow/master
sess.close()
```

Note that a regular session installs itself as the default session when it
is created in a `with` statement.  The common usage in non-interactive
programs is to follow that pattern:

```python
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a * b
with tf.Session():
  # We can also use 'c.eval()' here.
<<<<<<< HEAD
  print c.eval()
=======
  print(c.eval())
>>>>>>> tensorflow/master
```

- - -

<<<<<<< HEAD
#### `tf.InteractiveSession.__init__(target='', graph=None)` <a class="md-anchor" id="InteractiveSession.__init__"></a>
=======
#### `tf.InteractiveSession.__init__(target='', graph=None, config=None)` {#InteractiveSession.__init__}
>>>>>>> tensorflow/master

Creates a new interactive TensorFlow session.

If no `graph` argument is specified when constructing the session,
the default graph will be launched in the session. If you are
using more than one graph (created with `tf.Graph()` in the same
process, you will have to use different sessions for each graph,
but each graph can be used in multiple sessions. In this case, it
is often clearer to pass the graph to be launched explicitly to
the session constructor.

<<<<<<< HEAD
##### Args: <a class="md-anchor" id="AUTOGENERATED-args-"></a>
=======
##### Args:
>>>>>>> tensorflow/master


*  <b>`target`</b>: (Optional.) The execution engine to connect to.
    Defaults to using an in-process engine. At present, no value
    other than the empty string is supported.
*  <b>`graph`</b>: (Optional.) The `Graph` to be launched (described above).
<<<<<<< HEAD
=======
*  <b>`config`</b>: (Optional) `ConfigProto` proto used to configure the session.
>>>>>>> tensorflow/master


- - -

<<<<<<< HEAD
#### `tf.InteractiveSession.close()` <a class="md-anchor" id="InteractiveSession.close"></a>
=======
#### `tf.InteractiveSession.close()` {#InteractiveSession.close}
>>>>>>> tensorflow/master

Closes an `InteractiveSession`.




- - -

<<<<<<< HEAD
### `tf.get_default_session()` <a class="md-anchor" id="get_default_session"></a>
=======
### `tf.get_default_session()` {#get_default_session}
>>>>>>> tensorflow/master

Returns the default session for the current thread.

The returned `Session` will be the innermost session on which a
`Session` or `Session.as_default()` context has been entered.

<<<<<<< HEAD
*N.B.* The default session is a property of the current thread. If you
=======
NOTE: The default session is a property of the current thread. If you
>>>>>>> tensorflow/master
create a new thread, and wish to use the default session in that
thread, you must explicitly add a `with sess.as_default():` in that
thread's function.

<<<<<<< HEAD
##### Returns: <a class="md-anchor" id="AUTOGENERATED-returns-"></a>
=======
##### Returns:
>>>>>>> tensorflow/master

  The default `Session` being used in the current thread.



<<<<<<< HEAD
## Error classes <a class="md-anchor" id="AUTOGENERATED-error-classes"></a>

- - -

### `class tf.OpError` <a class="md-anchor" id="OpError"></a>
=======
## Error classes

- - -

### `class tf.OpError` {#OpError}
>>>>>>> tensorflow/master

A generic error that is raised when TensorFlow execution fails.

Whenever possible, the session will raise a more specific subclass
of `OpError` from the `tf.errors` module.

- - -

<<<<<<< HEAD
#### `tf.OpError.op` <a class="md-anchor" id="OpError.op"></a>
=======
#### `tf.OpError.op` {#OpError.op}
>>>>>>> tensorflow/master

The operation that failed, if known.

*N.B.* If the failed op was synthesized at runtime, e.g. a `Send`
or `Recv` op, there will be no corresponding
<<<<<<< HEAD
[`Operation`](../../api_docs/python/framework.md#Operation) object.  In that case, this
will return `None`, and you should instead use the
[`OpError.node_def`](#OpError.node_def) to discover information about the
op.

##### Returns: <a class="md-anchor" id="AUTOGENERATED-returns-"></a>

  The `Operation` that failed, or None.

- - -

#### `tf.OpError.node_def` <a class="md-anchor" id="OpError.node_def"></a>
=======
[`Operation`](../../api_docs/python/framework.md#Operation)
object.  In that case, this will return `None`, and you should
instead use the [`OpError.node_def`](#OpError.node_def) to
discover information about the op.

##### Returns:

  The `Operation` that failed, or None.


- - -

#### `tf.OpError.node_def` {#OpError.node_def}
>>>>>>> tensorflow/master

The `NodeDef` proto representing the op that failed.


<<<<<<< HEAD
#### Other Methods <a class="md-anchor" id="AUTOGENERATED-other-methods"></a>
- - -

#### `tf.OpError.__init__(node_def, op, message, error_code)` <a class="md-anchor" id="OpError.__init__"></a>

Creates a new OpError indicating that a particular op failed.

##### Args: <a class="md-anchor" id="AUTOGENERATED-args-"></a>


*  <b>`node_def`</b>: The graph_pb2.NodeDef proto representing the op that failed.
*  <b>`op`</b>: The ops.Operation that failed, if known; otherwise None.
*  <b>`message`</b>: The message string describing the failure.
*  <b>`error_code`</b>: The error_codes_pb2.Code describing the error.
=======

#### Other Methods
- - -

#### `tf.OpError.__init__(node_def, op, message, error_code)` {#OpError.__init__}

Creates a new `OpError` indicating that a particular op failed.

##### Args:


*  <b>`node_def`</b>: The `graph_pb2.NodeDef` proto representing the op that failed,
    if known; otherwise None.
*  <b>`op`</b>: The `ops.Operation` that failed, if known; otherwise None.
*  <b>`message`</b>: The message string describing the failure.
*  <b>`error_code`</b>: The `error_codes_pb2.Code` describing the error.
>>>>>>> tensorflow/master


- - -

<<<<<<< HEAD
#### `tf.OpError.error_code` <a class="md-anchor" id="OpError.error_code"></a>

The integer error code that describes the error.

- - -

#### `tf.OpError.message` <a class="md-anchor" id="OpError.message"></a>
=======
#### `tf.OpError.error_code` {#OpError.error_code}

The integer error code that describes the error.


- - -

#### `tf.OpError.message` {#OpError.message}
>>>>>>> tensorflow/master

The error message that describes the error.


<<<<<<< HEAD
- - -

### `class tf.errors.CancelledError` <a class="md-anchor" id="CancelledError"></a>
=======

- - -

### `class tf.errors.CancelledError` {#CancelledError}
>>>>>>> tensorflow/master

Raised when an operation or step is cancelled.

For example, a long-running operation (e.g.
[`queue.enqueue()`](../../api_docs/python/io_ops.md#QueueBase.enqueue) may be
cancelled by running another operation (e.g.
[`queue.close(cancel_pending_enqueues=True)`](../../api_docs/python/io_ops.md#QueueBase.close),
or by [closing the session](../../api_docs/python/client.md#Session.close).
A step that is running such a long-running operation will fail by raising
`CancelledError`.

- - -

<<<<<<< HEAD
#### `tf.errors.CancelledError.__init__(node_def, op, message)` <a class="md-anchor" id="CancelledError.__init__"></a>
=======
#### `tf.errors.CancelledError.__init__(node_def, op, message)` {#CancelledError.__init__}
>>>>>>> tensorflow/master

Creates a `CancelledError`.



- - -

<<<<<<< HEAD
### `class tf.errors.UnknownError` <a class="md-anchor" id="UnknownError"></a>
=======
### `class tf.errors.UnknownError` {#UnknownError}
>>>>>>> tensorflow/master

Unknown error.

An example of where this error may be returned is if a Status value
received from another address space belongs to an error-space that
is not known to this address space. Also errors raised by APIs that
do not return enough error information may be converted to this
error.

- - -

<<<<<<< HEAD
#### `tf.errors.UnknownError.__init__(node_def, op, message, error_code=2)` <a class="md-anchor" id="UnknownError.__init__"></a>
=======
#### `tf.errors.UnknownError.__init__(node_def, op, message, error_code=2)` {#UnknownError.__init__}
>>>>>>> tensorflow/master

Creates an `UnknownError`.



- - -

<<<<<<< HEAD
### `class tf.errors.InvalidArgumentError` <a class="md-anchor" id="InvalidArgumentError"></a>
=======
### `class tf.errors.InvalidArgumentError` {#InvalidArgumentError}
>>>>>>> tensorflow/master

Raised when an operation receives an invalid argument.

This may occur, for example, if an operation is receives an input
tensor that has an invalid value or shape. For example, the
[`tf.matmul()`](../../api_docs/python/math_ops.md#matmul) op will raise this
error if it receives an input that is not a matrix, and the
[`tf.reshape()`](../../api_docs/python/array_ops.md#reshape) op will raise
this error if the new shape does not match the number of elements in the input
tensor.

- - -

<<<<<<< HEAD
#### `tf.errors.InvalidArgumentError.__init__(node_def, op, message)` <a class="md-anchor" id="InvalidArgumentError.__init__"></a>
=======
#### `tf.errors.InvalidArgumentError.__init__(node_def, op, message)` {#InvalidArgumentError.__init__}
>>>>>>> tensorflow/master

Creates an `InvalidArgumentError`.



- - -

<<<<<<< HEAD
### `class tf.errors.DeadlineExceededError` <a class="md-anchor" id="DeadlineExceededError"></a>
=======
### `class tf.errors.DeadlineExceededError` {#DeadlineExceededError}
>>>>>>> tensorflow/master

Raised when a deadline expires before an operation could complete.

This exception is not currently used.

- - -

<<<<<<< HEAD
#### `tf.errors.DeadlineExceededError.__init__(node_def, op, message)` <a class="md-anchor" id="DeadlineExceededError.__init__"></a>
=======
#### `tf.errors.DeadlineExceededError.__init__(node_def, op, message)` {#DeadlineExceededError.__init__}
>>>>>>> tensorflow/master

Creates a `DeadlineExceededError`.



- - -

<<<<<<< HEAD
### `class tf.errors.NotFoundError` <a class="md-anchor" id="NotFoundError"></a>
=======
### `class tf.errors.NotFoundError` {#NotFoundError}
>>>>>>> tensorflow/master

Raised when a requested entity (e.g., a file or directory) was not found.

For example, running the
[`tf.WholeFileReader.read()`](../../api_docs/python/io_ops.md#WholeFileReader)
operation could raise `NotFoundError` if it receives the name of a file that
does not exist.

- - -

<<<<<<< HEAD
#### `tf.errors.NotFoundError.__init__(node_def, op, message)` <a class="md-anchor" id="NotFoundError.__init__"></a>
=======
#### `tf.errors.NotFoundError.__init__(node_def, op, message)` {#NotFoundError.__init__}
>>>>>>> tensorflow/master

Creates a `NotFoundError`.



- - -

<<<<<<< HEAD
### `class tf.errors.AlreadyExistsError` <a class="md-anchor" id="AlreadyExistsError"></a>
=======
### `class tf.errors.AlreadyExistsError` {#AlreadyExistsError}
>>>>>>> tensorflow/master

Raised when an entity that we attempted to create already exists.

For example, running an operation that saves a file
(e.g. [`tf.train.Saver.save()`](../../api_docs/python/train.md#Saver.save))
could potentially raise this exception if an explicit filename for an
existing file was passed.

- - -

<<<<<<< HEAD
#### `tf.errors.AlreadyExistsError.__init__(node_def, op, message)` <a class="md-anchor" id="AlreadyExistsError.__init__"></a>
=======
#### `tf.errors.AlreadyExistsError.__init__(node_def, op, message)` {#AlreadyExistsError.__init__}
>>>>>>> tensorflow/master

Creates an `AlreadyExistsError`.



- - -

<<<<<<< HEAD
### `class tf.errors.PermissionDeniedError` <a class="md-anchor" id="PermissionDeniedError"></a>
=======
### `class tf.errors.PermissionDeniedError` {#PermissionDeniedError}
>>>>>>> tensorflow/master

Raised when the caller does not have permission to run an operation.

For example, running the
[`tf.WholeFileReader.read()`](../../api_docs/python/io_ops.md#WholeFileReader)
operation could raise `PermissionDeniedError` if it receives the name of a
file for which the user does not have the read file permission.

- - -

<<<<<<< HEAD
#### `tf.errors.PermissionDeniedError.__init__(node_def, op, message)` <a class="md-anchor" id="PermissionDeniedError.__init__"></a>
=======
#### `tf.errors.PermissionDeniedError.__init__(node_def, op, message)` {#PermissionDeniedError.__init__}
>>>>>>> tensorflow/master

Creates a `PermissionDeniedError`.



- - -

<<<<<<< HEAD
### `class tf.errors.UnauthenticatedError` <a class="md-anchor" id="UnauthenticatedError"></a>
=======
### `class tf.errors.UnauthenticatedError` {#UnauthenticatedError}
>>>>>>> tensorflow/master

The request does not have valid authentication credentials.

This exception is not currently used.

- - -

<<<<<<< HEAD
#### `tf.errors.UnauthenticatedError.__init__(node_def, op, message)` <a class="md-anchor" id="UnauthenticatedError.__init__"></a>
=======
#### `tf.errors.UnauthenticatedError.__init__(node_def, op, message)` {#UnauthenticatedError.__init__}
>>>>>>> tensorflow/master

Creates an `UnauthenticatedError`.



- - -

<<<<<<< HEAD
### `class tf.errors.ResourceExhaustedError` <a class="md-anchor" id="ResourceExhaustedError"></a>
=======
### `class tf.errors.ResourceExhaustedError` {#ResourceExhaustedError}
>>>>>>> tensorflow/master

Some resource has been exhausted.

For example, this error might be raised if a per-user quota is
exhausted, or perhaps the entire file system is out of space.

- - -

<<<<<<< HEAD
#### `tf.errors.ResourceExhaustedError.__init__(node_def, op, message)` <a class="md-anchor" id="ResourceExhaustedError.__init__"></a>
=======
#### `tf.errors.ResourceExhaustedError.__init__(node_def, op, message)` {#ResourceExhaustedError.__init__}
>>>>>>> tensorflow/master

Creates a `ResourceExhaustedError`.



- - -

<<<<<<< HEAD
### `class tf.errors.FailedPreconditionError` <a class="md-anchor" id="FailedPreconditionError"></a>
=======
### `class tf.errors.FailedPreconditionError` {#FailedPreconditionError}
>>>>>>> tensorflow/master

Operation was rejected because the system is not in a state to execute it.

This exception is most commonly raised when running an operation
that reads a [`tf.Variable`](../../api_docs/python/state_ops.md#Variable)
before it has been initialized.

- - -

<<<<<<< HEAD
#### `tf.errors.FailedPreconditionError.__init__(node_def, op, message)` <a class="md-anchor" id="FailedPreconditionError.__init__"></a>
=======
#### `tf.errors.FailedPreconditionError.__init__(node_def, op, message)` {#FailedPreconditionError.__init__}
>>>>>>> tensorflow/master

Creates a `FailedPreconditionError`.



- - -

<<<<<<< HEAD
### `class tf.errors.AbortedError` <a class="md-anchor" id="AbortedError"></a>
=======
### `class tf.errors.AbortedError` {#AbortedError}
>>>>>>> tensorflow/master

The operation was aborted, typically due to a concurrent action.

For example, running a
[`queue.enqueue()`](../../api_docs/python/io_ops.md#QueueBase.enqueue)
operation may raise `AbortedError` if a
[`queue.close()`](../../api_docs/python/io_ops.md#QueueBase.close) operation
previously ran.

- - -

<<<<<<< HEAD
#### `tf.errors.AbortedError.__init__(node_def, op, message)` <a class="md-anchor" id="AbortedError.__init__"></a>
=======
#### `tf.errors.AbortedError.__init__(node_def, op, message)` {#AbortedError.__init__}
>>>>>>> tensorflow/master

Creates an `AbortedError`.



- - -

<<<<<<< HEAD
### `class tf.errors.OutOfRangeError` <a class="md-anchor" id="OutOfRangeError"></a>
=======
### `class tf.errors.OutOfRangeError` {#OutOfRangeError}
>>>>>>> tensorflow/master

Raised when an operation executed past the valid range.

This exception is raised in "end-of-file" conditions, such as when a
[`queue.dequeue()`](../../api_docs/python/io_ops.md#QueueBase.dequeue)
operation is blocked on an empty queue, and a
[`queue.close()`](../../api_docs/python/io_ops.md#QueueBase.close)
operation executes.

- - -

<<<<<<< HEAD
#### `tf.errors.OutOfRangeError.__init__(node_def, op, message)` <a class="md-anchor" id="OutOfRangeError.__init__"></a>
=======
#### `tf.errors.OutOfRangeError.__init__(node_def, op, message)` {#OutOfRangeError.__init__}
>>>>>>> tensorflow/master

Creates an `OutOfRangeError`.



- - -

<<<<<<< HEAD
### `class tf.errors.UnimplementedError` <a class="md-anchor" id="UnimplementedError"></a>
=======
### `class tf.errors.UnimplementedError` {#UnimplementedError}
>>>>>>> tensorflow/master

Raised when an operation has not been implemented.

Some operations may raise this error when passed otherwise-valid
arguments that it does not currently support. For example, running
the [`tf.nn.max_pool()`](../../api_docs/python/nn.md#max_pool) operation
would raise this error if pooling was requested on the batch dimension,
because this is not yet supported.

- - -

<<<<<<< HEAD
#### `tf.errors.UnimplementedError.__init__(node_def, op, message)` <a class="md-anchor" id="UnimplementedError.__init__"></a>
=======
#### `tf.errors.UnimplementedError.__init__(node_def, op, message)` {#UnimplementedError.__init__}
>>>>>>> tensorflow/master

Creates an `UnimplementedError`.



- - -

<<<<<<< HEAD
### `class tf.errors.InternalError` <a class="md-anchor" id="InternalError"></a>
=======
### `class tf.errors.InternalError` {#InternalError}
>>>>>>> tensorflow/master

Raised when the system experiences an internal error.

This exception is raised when some invariant expected by the runtime
has been broken. Catching this exception is not recommended.

- - -

<<<<<<< HEAD
#### `tf.errors.InternalError.__init__(node_def, op, message)` <a class="md-anchor" id="InternalError.__init__"></a>
=======
#### `tf.errors.InternalError.__init__(node_def, op, message)` {#InternalError.__init__}
>>>>>>> tensorflow/master

Creates an `InternalError`.



- - -

<<<<<<< HEAD
### `class tf.errors.UnavailableError` <a class="md-anchor" id="UnavailableError"></a>
=======
### `class tf.errors.UnavailableError` {#UnavailableError}
>>>>>>> tensorflow/master

Raised when the runtime is currently unavailable.

This exception is not currently used.

- - -

<<<<<<< HEAD
#### `tf.errors.UnavailableError.__init__(node_def, op, message)` <a class="md-anchor" id="UnavailableError.__init__"></a>
=======
#### `tf.errors.UnavailableError.__init__(node_def, op, message)` {#UnavailableError.__init__}
>>>>>>> tensorflow/master

Creates an `UnavailableError`.



- - -

<<<<<<< HEAD
### `class tf.errors.DataLossError` <a class="md-anchor" id="DataLossError"></a>
=======
### `class tf.errors.DataLossError` {#DataLossError}
>>>>>>> tensorflow/master

Raised when unrecoverable data loss or corruption is encountered.

For example, this may be raised by running a
[`tf.WholeFileReader.read()`](../../api_docs/python/io_ops.md#WholeFileReader)
operation, if the file is truncated while it is being read.

- - -

<<<<<<< HEAD
#### `tf.errors.DataLossError.__init__(node_def, op, message)` <a class="md-anchor" id="DataLossError.__init__"></a>
=======
#### `tf.errors.DataLossError.__init__(node_def, op, message)` {#DataLossError.__init__}
>>>>>>> tensorflow/master

Creates a `DataLossError`.



<<<<<<< HEAD
=======

## Other Functions and Classes
- - -

### `class tf.ClusterSpec` {#ClusterSpec}

A class for representing a Cluster.
- - -

#### `tf.ClusterSpec.__init__(cluster)` {#ClusterSpec.__init__}

Creates a `ClusterSpec`.

##### Args:


*  <b>`cluster`</b>: A dictionary mapping one or more job names to lists of network
    addresses, or a `tf.ClusterDef` protocol buffer.

##### Raises:


*  <b>`TypeError`</b>: If `cluster` is not a dictionary mapping strings to lists
    of strings, and not a `ClusterDef` proto buf.


- - -

#### `tf.ClusterSpec.as_cluster_def()` {#ClusterSpec.as_cluster_def}

Returns a `tf.ClusterDef` protocol buffer.


- - -

#### `tf.ClusterSpec.as_cluster_spec()` {#ClusterSpec.as_cluster_spec}

Returns a dictionary from job names to list of network addresses.



>>>>>>> tensorflow/master
